---
slug: "blog/ten-minutes-of-unicode"
date: "2024-11-13"
title: "From ASCII to Unicode"
description: "Explore how Unicode encodes text for consistent representation of characters across multiple platforms and languages."
categories: ["CS", "Python"]
tags: ["Unicode", "Character Encoding"]
featured: false
path: /hello-world
series: ""
---
import {Container, Divider, Link, Paper, Typography} from "@mui/material";
import {Box} from "@mui/system";
import ZoomableImage from "../../components/ZoomableImage";
import ImageWithText from "../../components/mdxblog/ImageParagraph";
import BlogLink from "../../components/mdxblog/BlogLink";
import NotePopupMicro from "../../components/mdxblog/NotePopup";
import ZigzagHelpText from "../../components/mdxblog/ZigzagHelpText";
import ShadowComment from "../../components/mdxblog/ShadowComment";
import HelperLinkText from "../../components/mdxblog/HelperLinkText";

<Box sx={{display: 'flex', flexDirection: 'row', justifyContent: "space-between", alignItems: "end", mb: 0}}>
    <Typography variant="h1" sx={{pt: 5}} gutterBottom>
        # {props.pageContext.frontmatter.title}
    </Typography>
    <Typography variant="h5" color="textSecondary" gutterBottom>
        {props.pageContext.frontmatter.date}
    </Typography>
</Box>
<Divider sx={{
    background: 'linear-gradient(to right, #ff4081, #1b1b1b)',
    height: '2px',
    width: "100%",
    borderRadius: '4px',
    margin: '2px 0',
    boxShadow: '0 0 10px rgba(255, 64, 129, 0.1)' // Adds a glowing shadow effect
}}/>

<Box>

</Box>
&nbsp;
## A Deep Dive into Unicode

The <BlogLink href="https://www.unicode.org/standard/standard.html">Unicode Standard</BlogLink> is a universal framework for encoding, representing, and managing text across digital systems — including computers, databases, and operating systems. Introduced in 1991, and maintained by the <BlogLink href="https://www.unicode.org/consortium/consort.html">Unicode Consortium</BlogLink>, it defines more than **150,000 characters** — covering everything from modern scripts to ancient, even extinct languages.

For example, thanks to Unicode, we can now easily render languages like <BlogLink href="https://www.cbc.ca/news/canada/thunder-bay/%E1%90%8A%E1%90%A3%E1%91%95%E1%94%9A%E1%90%A3%E1%90%A6%E1%90%83-%E1%90%81%E1%90%8F%E1%92%8B%E1%91%AD%E1%90%8D-%E1%90%85%E1%91%95%E1%90%B1%E1%93%87%E1%92%AA%E1%90%A3-%E1%93%82%E1%92%AA%E1%92%AA-%E1%90%85%E1%91%8E%E1%94%91%E1%91%AD%E1%94%91%E1%90%8D%E1%90%8F%E1%90%A3-%E1%92%B7%E1%94%A6-%E1%90%83%E1%90%A1%E1%91%BF%E1%93%AD%E1%90%A0-1.6385526" hoverText="Oji-Cree article on CBC">Oji-Cree</BlogLink> — a historically endangered language — directly in a browser. <HelperLinkText href="https://www.cbc.ca/news/canada/thunder-bay/first-person-rochelle-bragg-reclaiming-language-1.6371587" popoverText="Translation article">(translated here)</HelperLinkText>.

<ShadowComment>It’s pretty mind-blowing that prehistoric scripts can be rendered effortlessly online, right?</ShadowComment>

Because of its **ambition to be the final text encoding standard**, Unicode is a **layered** and **multi-faceted system**. To truly understand it, we need to explore these layers carefully — and that’s exactly what this article is designed to help you do.

#### **How This Deep Dive Will Work**

- Each section tackles one key concept or layer of Unicode.
- **Summary tables** at the end of each section help reinforce learning.
- **Real Python code examples** are provided throughout — so you can immediately apply the concepts hands-on.

By the end, you’ll have a **practical, layered understanding** of Unicode — from its historical roots to its modern applications in encoding, text processing, and even security.

Let's begin our journey into the heart of how text really works - I hope you'll like it!

### Layer Zero: Pre-Unicode — ASCII and Code Pages
#### The Era Before Unicode

Before Unicode, text encoding was fragmented into various character encodings specific to
languages or regions (e.g., ASCII, ISO 8859, and Windows-1252). These encoding standards often conflicted,
resulting in garbled text when transferred across systems that used different encoding schemes - a phenomenon that has its own name: *mojibake* (Japanese for "character transformation", or simply: gibberish).

<ZoomableImage src="/graphics/blog/10-minutes-of-unicode/mojibake01.png" center="true"/>

### Layer One: Unicode Core Concepts
#### Why There’s No Such Thing as "Plain Text"

When dealing with text as bytes, knowing the encoding used to generate those bytes is crucial.
(Full explanation and Python code sample you provided.)

(Your nice wrapping conclusion fits well here too.)

### Layer Two: Scripts, Symbols, and Categories
#### Scripts
The first layer of Unicode is that of **scripts** and **symbols**.

(Your detailed explanation of Latin script, Cyrillic script, and the note about Unicode supporting 168 scripts.)

#### Symbols

Symbols are characters that are not part of a writing-system...

(Your bullet list of mathematical, currency, emoji examples.)

#### The Intersection of Scripts & Symbols

Scripts and symbols are not rigid, mutually exclusive categories in Unicode...
(Your explanation and example of Latin Script containing symbols.)


### Layer Three: Code Points and Code Blocks
#### Code Blocks & Code Points

Unicode uses two other concepts that are functionally significant...
(Your entire explanation about codepoints, glyphs, fonts, and character vs glyph distinctions.)

#### Characters, not glyphs!

(Your text about glyph rendering and code point identity.)

(Insert here: Your ZoomableImage showing glyph rendering differences.)

Unicode is therefore not a text-encoding scheme...

(Your explanation about Unicode versus encodings.)

Some scripts like Armenian...

(Your note about one-to-one vs one-to-many script-to-language relationships.)

Basic Latin script...

(Your ASCII to Unicode explanation about "Hello", identical code points.)

(Insert your ZoomableImage of Unicode Basic Latin block.)


### Layer Four: Unicode Planes
(Note: You haven't written anything yet specifically about Planes — BMP, SMP, etc. I can generate a fitting paragraph here if you want.)

Placeholder: To Be Written
### Layer Five: Encodings — UTF-8, UTF-16, UTF-32
#### How UTF-8 Works

UTF-8 is a variable-length encoding that represents Unicode code points in 1 to 4 bytes...

(Your example and explanation about UTF-8.)


#### Notes on Encoding Variants

UTF-16 uses 2 or 4 bytes per character...
UTF-32 uses 4 bytes uniformly...

(Your notes about tradeoffs of UTF-8 vs UTF-16 vs UTF-32.)

#### Practical Advice for Working with Unicode

Handling Unicode effectively requires knowing:
(Your bullet points about representations, encoding consistency, pitfalls.)

### Layer 6: Unicode Properties
Layer Six: Unicode Properties
(Note: You haven't specifically explained General Categories, Bidi properties, Numeric values, Combining classes yet.)

Placeholder: To Be Written

### Layer 7: Unicode Normalization
Layer Seven: Unicode Normalization
(Note: You haven't yet explained NFC, NFD, NFKC, NFKD normalization.)

Placeholder: To Be Written

### Layer 8: Unicode Security Issues
Layer Eight: Unicode Security Issues
(Note: You haven't yet covered homoglyph attacks, Trojan Source attacks, zero-width attacks.)

Placeholder: To Be Written

### Layer 9: Unicode in Systems and Protocols
#### Why There’s No Such Thing as "Plain Text" (continued)

(Your examples fit here too because you explain encoding in internet protocols, HTTP headers, etc.)

- Over the internet, it's specified in HTTP headers...
- In HTML/XML, it's in `<meta charset="UTF-8">`...

### Layer 10: Advanced Unicode Algorithms
Layer Ten: Advanced Unicode Algorithms
(Note: You haven't yet covered Unicode Text Segmentation (TR29), Collation (sorting), Bidirectional Algorithm.)

Placeholder: To Be Written

### Layer One: Scripts & Symbols

## Code Blocks & Code Points


## The Era Before Unicode
Before Unicode, text encoding was fragmented into various character encodings specific to
languages or regions (e.g., ASCII, ISO 8859, and Windows-1252). These encoding standards often conflicted,
resulting in garbled text when transferred across systems that used different encoding schemes - a phenomenon that have it's own name: *mojibake* which is Japanese and means "character transformation", or more simply: gibberish.

<ZoomableImage src="/graphics/blog/10-minutes-of-unicode/mojibake01.png" center="true"/>
For example:
- ASCII uses one 8-bit byte per character, but its code points cover only the basic Latin alphabet and control characters.
- Extended standards, like ISO 8859 and Windows-1252, add characters but remain limited by encoding space, often overlapping in ways that caused compatibility issues.

Unicode was created to unify these encoding standards into a single, comprehensive system to represent most of the world's languages.

## Why There’s No Such Thing as "Plain Text"
When dealing with text as bytes, knowing the encoding used to generate those bytes is crucial. Text without encoding context is meaningless to a computer, as bytes are just binary data until interpreted by an encoding scheme.

## How UTF-8 Works

## Final Note on Unicode


# See also:
https://peps.python.org/pep-0263/ PEP 263 – Defining Python Source Code Encodings

| Encoding      | Byte Length    | Supports          | Use Cases                                       |
|---------------|----------------|-------------------|-------------------------------------------------|
| ASCII         | 1 byte         | Basic English     | Legacy systems, programming, protocols         |
| ISO-8859-1    | 1 byte         | Western Europe    | Web pages, legacy databases, email             |
| UTF-16        | 2 or 4 bytes   | All Unicode       | Java, Windows, some databases                  |
| UTF-32        | 4 bytes        | All Unicode       | Some internal systems, databases               |
| Windows-1252  | 1 byte         | Western Europe    | Legacy Windows apps, web pages                 |
| Shift-JIS     | 1 or 2 bytes   | Japanese          | Japanese text encoding                         |
| GB2312        | 2 bytes        | Simplified Chinese| Chinese mainland web pages, files             |
| Big5          | 2 bytes        | Traditional Chinese| Taiwan, Hong Kong legacy systems               |
| EBCDIC        | 1 byte         | IBM Mainframes    | IBM mainframe systems                          |